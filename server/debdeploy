#! /usr/bin/python
# -*- coding: utf-8 -*-

# TODO:
# reinstate rollback handling
# revamp and readd restart handling

from __future__ import print_function

import argparse
import code
import cumin
import datetime
import json
import logging
import os
import pkgutil
import pydoc
import signal
import sys
import textwrap

from ClusterShell.NodeSet import NodeSet

from cumin import query, transport, transports
from debdeploy_conf import *
from debdeploy_updatespec import *

if os.geteuid() != 0:
    print("debdeploy needs to be run as root")
    sys.exit(1)


cumin_config = cumin.Config()
conf = DebDeployConfig("/etc/debdeploy.conf")

logging.basicConfig(filename='/var/log/debdeploy/debdeploy.log',
                    format='%(levelname)s: %(asctime)s : %(funcName)s : %(message)s',
                    level=logging.INFO)

logger = logging.getLogger('debdeploy')
if conf.debug:
    logger.setLevel(logging.DEBUG)


class logpager:
    threshold = 20  # if pager buffer contains more than <threshold> lines, use the pager

    def __init__(self):
        self.buf = ""

    def add(self, *args):
        for i in args:
            self.buf += str(i)
        self.buf += "\n"

    def add_nb(self, *args):
        for i in args:
            self.buf += str(i)

    def show(self):
        if self.buf.count("\n") > self.threshold:
            pydoc.pager(self.buf)
        else:
            print(self.buf)


def show_unreachable_hosts(worker):
    unreachable_hosts = []
    for node in worker._handler_instance.nodes.itervalues():
        if node.state.is_failed:
            unreachable_hosts.append(node.name)

    if unreachable_hosts:
        print("\nThe following hosts were unreachable:")
        for host in unreachable_hosts:
            print(host)

def run_cumin(cmd, alias):
    '''
    Run Cumin and discard the output shown by the transport

    cmd   : The Command to be executed
    alias : A Cumin alias for a group of servers
    '''

    with open(os.devnull, 'w') as discard_output:

        try:
            oldstdout = sys.stdout
            oldstderr = sys.stderr
            sys.stdout = discard_output
            sys.stderr = discard_output

            hosts = query.Query(cumin_config, logger=logger).execute('A:' + alias)
            target = transports.Target(hosts, batch_size=100, logger=logger)
            worker = transport.Transport.new(cumin_config, target, logger=logger)
            worker.commands = [cmd]

            worker.handler = 'sync'
            worker.success_threshold = 0.1
            exit_code = worker.execute()

            return worker

        except cumin.backends.InvalidQueryError as e:
            print("Invalid query:")
            print(e)
            sys.exit(1)
        finally:
            sys.stdout = oldstdout
            sys.stderr = oldstderr


def deploy_update(source, update_type, update_file, servergroup, supported_distros, fixes):
    '''
    Initiate a deployment.

    source      : Name of the source package (string)
    update_type : Various types of packages have different outcome, see doc/readme.txt (string)
    update_file : Filename of update specification (string)
    servergroup : The name of the server group (string)
    '''

    update_desc = {}
    update_desc["tool"] = "Non-daemon update, no service restart needed"
    update_desc["daemon-direct"] = "Daemon update without user impact"
    update_desc["daemon-disrupt"] = "Daemon update with service availability impact"
    update_desc["library"] = "Library update, several services might need to be restarted"

    print("Rolling out", source, ": ")
    print(update_desc[update_type])
    print()

    cmd = '/usr/bin/debdeploy-deploy --source ' + source + ' --updatespec '
    for distro in fixes:
        if fixes[distro]:
            cmd += str(supported_distros[distro][0][0]) + "_" + str(supported_distros[distro][0][1]) + "_" + str(fixes[distro]) + " "

    worker = run_cumin(cmd, servergroup)

    status_print = textwrap.TextWrapper(initial_indent='  ')
    for nodeset, output in worker.get_results():
        msg = str(output)
        try:
            result = json.loads(msg)

            status_codes = {"NOCHANGE": "These hosts are already up-to-date:",
                            "OSDIFFERS": "The update spec doesn't apply to the OS of the following hosts:",
                            "NOBINARY": "The package to be updated isn't installed on these hosts:",
                            "INVALID_DISTRO": "Found an unsupported distro:"}

            if result['status'] in status_codes:
                print(status_codes[result['status']])
                print(status_print.fill(str(nodeset)))
                print()
            elif result['success'] and result['status'] == 'UPDATES':
                updates = result['data']
                for package in updates.keys():
                    print(package, "was updated: ", updates[package][0], "->", updates[package][1])
                    print(status_print.fill(str(nodeset)))
                    print()
            else:
                if result['success']:
                    print("Unspecified return code:")
                else:
                    print("Unspecified error:")
                print(result['status'])

        except ValueError as e:
            print("Could not decode JSON response for")
            print(nodeset)
            print(e)

        except KeyError as e:
            print("Failed to read expected value", e, ":")
            print(nodeset)

    show_unreachable_hosts(worker)


def detect_restarts(libnames, servergroup):
    '''
    Query for necessary restarts after a library or interpreter upgrade

    libnames    : A list of library base names, e.g. libssl for
                  /usr/lib/x86_64-linux-gnu/libssl.so.1.0.0 (list of strings)
    servergroup : The name of the server group for which process restarts should be queried (string)
    '''

    cmd = '/usr/bin/debdeploy-restarts --libname ' + ' '.join(libnames)

    worker = run_cumin(cmd, servergroup)

    restarts_per_lib = {}
    for nodeset, output in worker.get_results():
        msg = str(output)

        try:
            result = json.loads(msg)
            if result['success']:
                if result['status'] == 'RESTARTS':
                    restarts = result['data']
                    if restarts:
                        for library in restarts.keys():
                            if not restarts_per_lib.get(library, None):
                                restarts_per_lib[library] = {}

                                for program in restarts[library]:
                                    if not restarts_per_lib[library].get(program, None):
                                        restarts_per_lib[library][program] = []
                                    restarts_per_lib[library][program] = nodeset
                elif result['status'] == 'NO_RESTARTS_NEEDED':
                    print("No service needs a restart")

        except ValueError as e:
            print("Could not decode JSON response for")
            print(nodeset)
            print(e)

    for lib in restarts_per_lib:
        print("Restarts for", lib, ":")
        for program in restarts_per_lib[lib]:
            print("  ", program)
            print("      " + str(restarts_per_lib[lib][program]) + " (" + str(len(restarts_per_lib[lib][program])) + " hosts)")

    show_unreachable_hosts(worker)


def detect_rev_deps(pkgnames, servergroup):
    '''
    Query for necessary restarts after a library or interpreter upgrade

    pkgnames    : A list of package names for which reverse dependencies are displayed,
                  e.g. libssl1.1 (list of strings)
    servergroup : The name of the server group for which process restarts should be queried (string)
    '''

    cmd = '/usr/bin/debdeploy-revdeps ' + ' '.join(pkgnames)

    worker = run_cumin(cmd, servergroup)

    status_print = textwrap.TextWrapper(initial_indent='  ')
    for nodeset, output in worker.get_results():
        msg = str(output)

        try:
            result = json.loads(msg)
            if result['success']:
                if result['status'] == 'LIST_DEPS':
                    if result['data']:
                        print(nodeset)
                        for service in result['data']:
                            print(status_print.fill(service))
                    else:
                        print(nodeset)
                        print(status_print.fill("No reverse dependencies installed"))
            else:
                error_codes = {"QUERY_FAIL": "Failed to query reverse dependencies:",
                               "INVALID_PACKAGE": "Unknown package:"}

                if result['status'] in error_codes:
                    print(error_codes[result['status']])
                    print(status_print.fill(str(nodeset)))

        except ValueError as e:
            print("Could not decode JSON response for")
            print(nodeset)
            print(e)

        except KeyError as e:
            print("Failed to read expected value", e, ":")
            print(nodeset)

    show_unreachable_hosts(worker)


def main():
    p = argparse.ArgumentParser()

    p.add_argument("--verbose", action="store_true", dest="verbose",
                   help="Enable verbose output, e.g. show full apt output in status-deploy and \
                   status-rollback")

    subp = p.add_subparsers(title='Command', description='Valid commands', dest='command')
    parser_deps = subp.add_parser('query_deps', help='Query for necessary restarts after a library or interpreter upgrade')
    parser_deps.add_argument('--packages', action='store', nargs='+',
                             help="Packages to query reverse dependencies", required=True)
    parser_deps.add_argument("-s", "--servers", action="store", type=str, dest="serverlist",
                             help="The group of servers for which reverse dependencies should be queried",
                             required=True)

    parser_deploy = subp.add_parser('deploy', help='Install a software update')
    parser_deploy.add_argument("-s", "--servers", action="store", type=str, dest="serverlist",
                               help="The group of servers on which the update should be applied",
                               required=True)
    parser_deploy.add_argument("-u", "--update", action="store", type=str, dest="updatefile",
                               help="A YAML file containing the update specification (which source package to \
                               update and the respective fixed versions", required=True)

    parser_restart = subp.add_parser('query_restart', help='Query necesssary service restarts after library update')
    parser_restart.add_argument("-s", "--servers", action="store", type=str, dest="serverlist",
                                help="The group of servers for which necessary service restarts should be detected",
                                required=True)
    parser_restart.add_argument("-u", "--update", action="store", type=str, dest="updatefile",
                                help="A YAML file containing the update specification (which source package to \
                                update and the respective fixed versions", required=True)

    opt = p.parse_args()

    if opt.command == "deploy":
        update = DebDeployUpdateSpec(opt.updatefile, conf.supported_distros)
        deploy_update(update.source, update.update_type, opt.updatefile, opt.serverlist,
                      conf.supported_distros, update.fixes)

    elif opt.command == "query_restart":
        update = DebDeployUpdateSpec(opt.updatefile, conf.supported_distros)
        detect_restarts(update.libraries, opt.serverlist)

    elif opt.command == "query_deps":
        detect_rev_deps(opt.packages, opt.serverlist)


if __name__ == '__main__':
    main()


# Local variables:
# mode: python
# End:
