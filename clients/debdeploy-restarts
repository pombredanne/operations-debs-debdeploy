#! /usr/bin/python3
# -*- coding: utf-8 -*-
'''
Module for listing necessary service restarts after a library update (used by "query_restart" command)
'''

import logging
import subprocess
import os
import sys
import argparse
import json
import collections
from logging.handlers import RotatingFileHandler

logger = logging.getLogger('debdeploy')


def parse_args():
    p = argparse.ArgumentParser(
        description='debdeploy-restarts - List necessary restarts after library update (used by "query_restart" command)')
    p.add_argument('--console', action='store_true', default=False,
                   help='Enable additional console output')
    p.add_argument('--libname', action='store', nargs='+', required=True)

    args = p.parse_args(sys.argv[1:])

    return args


def setup_logger(verbose=False, console_output=False):
    log_file = "/var/log/debdeploy/updates.log"

    log_path = os.path.dirname(log_file)
    if not os.path.exists(log_path):
        os.makedirs(log_path, 0o770)

    log_formatter = logging.Formatter(fmt='%(asctime)s (%(levelname)s) %(message)s')
    log_handler = RotatingFileHandler(log_file, maxBytes=(5 * (1024**2)), backupCount=30)
    log_handler.setFormatter(log_formatter)
    logger.addHandler(log_handler)
    logger.raiseExceptions = False

    if console_output:
        console = logging.StreamHandler()
        logging.getLogger('debdeploy').addHandler(console)

    if verbose:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)


def get_deleted_files():
    '''
    This function returns a list open file handles, which have a reference to deleted
    files, this usually occurs after library upgrades. The original code in debdepoy
    was parsing /proc itself, but we now rely on parsing the lsof which is much more
    robust since it allows to directly query deleted filed
    '''

    deleted_files = []
    false_positives = ['/dev/zero']

    try:
        del_files = subprocess.check_output(["lsof", "+c", "15", "-nXd", "DEL"],
                                            universal_newlines=True)
    except subprocess.CalledProcessError as e:
        logger.info("Could not determine host architecture", e.returncode)
        sys.exit(1)

    for line in del_files.splitlines():
        cols = line.split()
        try:
            if len(cols) == 8:
                command, pid, filename = [cols[x] for x in (0, 1, 7)]
                if filename not in false_positives:
                    deleted_files.append((command, pid, filename))
        except ValueError:
            continue

    return deleted_files


def result(success, status, restarts_needed):
    '''
    Generates a JSON data set to return to Cumin.
    success: Did an error occur or not? (boolean)
    status: Status code (string)
    restarts_needed: dictionary of process names with a dictionary
        of PIDs with a list of file references
    '''

    data = collections.OrderedDict()
    data['success'] = success
    data['status'] = status
    data['data'] = restarts_needed

    return json.dumps(data)


def main():
    '''
    Updates all installed binary packages of the source package
    to the specified version.
    '''
    args = parse_args()

    setup_logger(False, args.console)

    deleted_files = get_deleted_files()
    restarts_needed = collections.defaultdict(set)
    return_restarts = {}

    for i in deleted_files:
        procname, pid, fname = (i)
        for libname in args.libname:
            if fname.find(libname) != -1:
                if not restarts_needed.get(fname, None):
                    restarts_needed[fname].add(procname)

    for i in restarts_needed.keys():
        return_restarts[i] = list(restarts_needed[i])

    if len(restarts_needed) == 0:
        return result(True, "NO_RESTARTS_NEEDED", {})
    else:
        logger.info("These services need a restart:")
        for i in restarts_needed:
            logger.info(i + " (" + str(len(restarts_needed)) + " processes)")
        return result(True, "RESTARTS", return_restarts)


if __name__ == '__main__':
    print(main())

# Local variables:
# mode: python
# End:
