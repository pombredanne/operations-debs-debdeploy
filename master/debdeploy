#! /usr/bin/python
# -*- coding: utf-8 -*-

import sys, optparse, logging, os, datetime

if os.geteuid() != 0:
    print "debdeploy needs to be run as root"
    sys.exit(1)

from debdeploy_conf import *

conf = DebDeployConfig("/etc/debdeploy.conf")

if conf.debug:
    logging.basicConfig(filename='/var/log/debdeploy/debdeploy.log', format='%(levelname)s: %(asctime)s : %(funcName)s : %(message)s', level=logging.DEBUG)
else:
    logging.basicConfig(filename='/var/log/debdeploy/debdeploy.log', format='%(levelname)s: %(asctime)s : %(funcName)s : %(message)s', level=logging.INFO)

import salt
from salt.scripts import salt_run
from debdeploy_joblog import *
from debdeploy_updatespec import *
#from debdeploy_pkgdb import *

def display_status(rollback_mode=False):
    '''
    Deployment and rollback jobs are started asynchrously by Salt. The 
    This function displays the result of a previous deployment run.

    If rollback_mode is enabled, the status of a rollback job is displayed (mostly the
    same, but the job ID is looked up in a different database and some status messages
    are different).
    '''

    runner = salt.runner.RunnerClient(salt.config.master_config('/etc/salt/minion'))

    amount_of_hosts = 0
    add_cnt = {}
    remove_cnt = {}
    update_cnt = {}
    install_errors = []
    restart_cnt = {}

    if rollback_mode:
        if not joblogdb.does_job_exist(opt.updatefile, opt.serverlist):
            print opt.updatefile, "hasn't been deployed yet for this server group (", opt.serverlist, "), so we can't roll it back either."
            sys.exit(0)

        if not joblogdb.has_been_rolled_back(opt.updatefile, opt.serverlist):
            print opt.updatefile, "hasn't been rolled-back yet for this server group (", opt.serverlist, ")"
            sys.exit(0)
    else:
        if not joblogdb.does_job_exist(opt.updatefile, opt.serverlist):
            print opt.updatefile, "hasn't been deployed yet for this server group (", opt.serverlist, ")"
            sys.exit(0)

    if rollback_mode:
        jid = joblogdb.get_rollbackid(opt.updatefile, opt.serverlist)
    else:
        jid = joblogdb.get_jobid(opt.updatefile, opt.serverlist)

    # SaltRunner always emits its status on stdout, https://github.com/saltstack/salt/issues/21392
    # Can be dropped once fixed upstream
    with open('/dev/null', 'w') as discard_output:
        oldstdout = sys.stdout
        sys.stdout = discard_output
        job = runner.cmd('jobs.print_job', (jid,))
        sys.stdout = oldstdout
    if not job:
        print "Job " + str(jid) + " hasn't finished yet, please check again later"
        sys.exit(0)

    res = job[jid]['Result']
    if not res:
        print "Job hasn't finished yet, please check again later"
        sys.exit(0)

    amount_of_hosts += len(res.keys())

    for host in res:
        added = False
        if res[host]['return'].has_key('additions'):
            added = res[host]['return']['additions']
        removed = False
        if res[host]['return'].has_key('removals'):
            removed = res[host]['return']['removals']
        updated = False
        if res[host]['return'].has_key('updated'):
            updated = res[host]['return']['updated']
        restart = False
        if res[host]['return'].has_key('restart'):
            restart = res[host]['return']['restart']

        print host + ":"
        if added:
            print "  Added packages:", host['return']['additions']
            for added_pkg in host['return']['additions']:
                if not add_cnt.get(added_pkg, None):
                    add_cnt[added_pkg] = 1
                else:
                    add_cnt[added_pkg] += 1

        elif removed:
            print "  Removed packages:", host['return']['removals']
            for removed_pkg in host['return']['removals']:
                if not remove_cnt.get(removed_pkg, None):
                    remove_cnt[removed_pkg] = 1
                else:
                    remove_cnt[removed_pkg] += 1

        elif updated and len(updated.keys()) > 0:
            print "  Updated packages:"
            for k in updated:
                print "    " + k + ": " + updated[k][0] + " -> " + updated[k][1]

                updated_idx = k + ": " + updated[k][0] + " -> " + updated[k][1]
                if not update_cnt.get(updated_idx, None):
                    update_cnt[updated_idx] = 1
                else:
                    update_cnt[updated_idx] += 1

        else:
            print "  No change"


        if restart:
            for process in restart:
                if len(process) > 0:
                    if not restart_cnt.get(process, None):
                        restart_cnt[process] = []
                        restart_cnt[process].append(host)
                    else:
                        restart_cnt[process].append(host)

        # Detect installation errors and collect them to display an error list
        # across all Salt grains
        # apt doesn't provide more fine-grained error reporting other than
        # 0/success and 100/error, so we need to parse stderr for some common
        # error patterns
        if res[host]['return'].has_key('aptreturn') and res[host]['return']['aptreturn'] == 100:
            if res[host]['return']['apterrlog'].find("Could not get lock /var/lib/dpkg/lock") != -1:
                install_errors.append(host + ": The dpkg status database is locked, possibly a conflicting package installation")
            else:
                install_errors.append(host + ": Unknown installation error")

        if opt.verbose:
            print
            if res[host]['return'].has_key('aptlog'):
                indented = ['  ' + l for l in res[host]['return']['aptlog'].splitlines()]
            print "\n".join(indented)

    print 
    print 
    if rollback_mode:
        print "Rollback summary:"
        print "Number of hosts in this rollback run:", amount_of_hosts
    else:
        print "Deployment summary:"
        print "Number of hosts in this deployment run:", amount_of_hosts


    if len(add_cnt.keys()) == 0:
        print "No packages were added"
    else:
        print "Added packages:"
        for pkg in add_cnt:
            print pkg, "on", add_cnt[pkg], "hosts"

    if len(remove_cnt.keys()) == 0:
        print "No packages were removed"
    else:
        print "Removed packages:"
        for pkg in remove_cnt:
            print pkg, "on", remove_cnt[pkg], "hosts"

    if len(update_cnt.keys()) == 0:
        print "No packages were updated"
    else:
        print "Updated packages:"
        for pkg in sorted(update_cnt.keys()):
            print pkg, "on", update_cnt[pkg], "hosts"

    print

    if len(restart_cnt.keys()) == 0:
        print "No restarts are needed"
    else:
        print "Restarts needed:"
        for process in sorted(restart_cnt.keys()):
            print process, "on", len(restart_cnt[process]), "hosts:"
            print "  ",
            for i in restart_cnt[process]:
                print i,
            print

    print
    print "Error summary:"

    if len(install_errors) == 0:
        print "No errors found"
    else:
        for i in install_errors:
            print i

def deploy_update(source, update_type, grains, update_file, servergroup):
    '''
    Initiate a deployment. The job is processed asynchrously by Salt.

    source      : Name of the source package (string)
    update_type : Various types of packages have different outcome, see doc/readme.txt (string)
    grains      : Apply the update on this list of Salt grains (list of strings)
    update_file : Filename of update specification (string)
    servergroup : The name of the server group (string)
    '''

    update_desc = {}
    update_desc["tool"] = "Non-daemon update, no service restart needed"
    update_desc["daemon-direct"] = "Daemon update without user impact"
    update_desc["daemon-disrupt"] = "Daemon update with service availability impact"
    update_desc["library"] = "Library update, several services might need to be restarted"

    print "Rolling out", source, ":",
    print update_desc[update_type]

    target = ""
    if update_type in ["daemon-cluster", "reboot", "reboot-cluster"]:
        print "Not implemented yet"
        sys.exit(1)

    if joblogdb.has_been_rolled_back(update_file, servergroup):
        print update_file, "was already deployed and rolled back for this server group, if you want to redeploy you need to assign a different name"
        sys.exit(1)

    if joblogdb.does_job_exist(update_file, servergroup):
        print update_file, "was already deployed for this server group (", i, "), if you want to rollback the change use the <rollback> command."
        sys.exit(1)

    for i in grains:
        target += 'G@' + i + ' or '

    target = target[:-4]
    jid = client.cmd_async(target, 'debdeploy-minion.deploy', [source, update_type, update.fixes], expr_form='compound', ret='debdeploy-log')
    logging.info("Initiated rollout of spec file " + update_file + " (source package " + source + ") on grain compound " + target + " (salt job id: " + str(jid) + ")")
    joblogdb.add_job(update_file, servergroup, jid)


def restart(grains, processes):
    '''
    Trigger process restarts for a set of servers

    grains      : Apply the update on this list of Salt grains (list of strings)
    processes   : A list of processes to restart (list of strings)
    '''

    c = 0
    c_success = {}
    c_failed  = {}
    c_stopped = {}

    print "Restarting services. Use --verbose to also display non-failing restarts."
    logging.info("Initiated restart of process(es) " + str(processes) + " on grain compound " + str(grains))

    for i in grains:
        r = client.cmd(i, 'debdeploy-minion.restart_service', [processes], expr_form='grain')
        for host in r:
            c += 1
            if opt.verbose:
                print host + ":"
            for process in r[host]:
                c_success.setdefault(process, 0)
                c_failed.setdefault(process, 0)
                c_stopped.setdefault(process, 0)

                if r[host][process] == 0:
                    c_success[process] += 1
                    if opt.verbose:
                        print "  ", process, "successfully restarted"
                elif r[host][process] == 1:
                    c_failed[process] += 1
                    if opt.verbose:
                        print "  ", process, "failed to restart on", host
                elif r[host][process] == 2:
                    c_stopped[process] += 1
                    if opt.verbose:
                        print "  ", process, "wasn't running on", host, ", not restarted"
                elif r[host][process] == 3:
                    c_failed[process] += 1
                    if opt.verbose:
                        print " Restart handler", process, "could not be found on", host

    if opt.verbose:
        print
    print "Restart summary:"
    for proc in c_success:
        print proc, "successfully restarted on", c_success[proc], "out of", c, "hosts."
        logging.info(proc + " successfully restarted on " + str(c_success[proc]) + " out of " +  str(c) + " hosts.")

    for proc in c_failed:
        if c_failed[proc] > 0:
            print proc, "failed to restart on", c_failed[proc], "out of", c, "hosts."
            logging.info(proc + " failed to restart on " + str(c_failed[proc]) + " out of " +  str(c) + " hosts.")

    for proc in c_stopped:
        if c_stopped[proc] > 0:
            print proc, "wasn't running on on", c_stopped[proc], "out of", c, "hosts."
            logging.info(proc + " wasn't running on on " + str(c_stopped[proc]) + " out of " +  str(c) + " hosts.")


def list_server_groups(update=None):
    '''
    List all available server groups

    update      : If an update is specified, it is displayed whether an update
                  has already been deployed for that group.
    '''

    if not update:
        for servergroup in sorted(conf.server_groups):
            print servergroup
    else:
        done_list = []
        missing_list = []

        for servergroup in conf.server_groups:
            job_ran = False
            if joblogdb.does_job_exist(update, servergroup):
                job_ran = True
            if job_ran:
                done_list.append(servergroup)
            else:
                missing_list.append(servergroup)

        print update, "has been applied to these server groups:"
        for i in sorted(done_list):
            print i

        print
        print update, "hasn't been applied to these server groups:"
        for i in sorted(missing_list):
            print i

def list_server_group_members(server_group):
    '''
    Show all servers represented by a server group

    server_group        : The name of a server group (as defined in /etc/debdeploy.conf)
    '''

    print "Server group", server_group, ":"
    members = client.cmd('*', 'match.grain', conf.server_groups[server_group])
    for i in sorted(members):
        print i

def rollback(servergroup, update_file):
    '''
    Trigger process restarts for a set of servers

    servergroup      : Rollback an update on this server group (string)
    update_file : Filename of update specification (string)
    '''

    if not joblogdb.does_job_exist(update_file, servergroup):
        print "No software deployment for " + update_file + " exists."
        sys.exit(1)
    
    jid = ""
    if opt.jobid:
        jid = opt.jobid
    else:
        jid = joblogdb.get_jobid(update_file, servergroup)
    print "Initiated rollback for JID", jid
    logging.info("Initiated rollback for JID" + jid)

    target = ""
    for i in conf.server_groups[servergroup]:
        target += 'G@' + i + ' or '
    target = target[:-4]

    rid = client.cmd_async(target, 'debdeploy-minion.rollback', [jid], expr_form='compound')

    joblogdb.mark_as_rolled_back(jid, rid)

client = salt.client.LocalClient()
joblogdb = DebDeployJobLog("/var/lib/debdeploy/jobdb.sqlite")
#pkgdb = DebDeployPkgDB("/var/lib/debdeploy/pkgdb.sqlite")

op = optparse.OptionParser()
op.add_option("-u", "--update", action="store", type="string", dest="updatefile", help="A YAML file containing the update specification (which source package to update and the respective fixed versions")
op.add_option("-s", "--servers", action="store", type="string", dest="serverlist", help="The group of servers on which the update should be applied")
op.add_option("-j", "--jobid", action="store", type="string", dest="jobid", help="Some commands (e.g. rollout require) require a specific job ID in case multiple invocations of an update have been made")
op.add_option("--host", action="store", type="string", dest="host", help="Some commands (e.g. pkgdb-source) a specific hostname")
op.add_option("--verbose", action="store_true", dest="verbose", help="Enable verbose output, e.g. show full apt output in status-deploy and status-rollback")
op.add_option("-p", "--program", action="append", type="string", dest="program", help="The program(s) to restart on a server group")


op.set_usage("debdeploy-master [options] command \n \
  The following commands are supported: \n\n \
  deploy                     : Install a software update, requires --update and --servers \n \
  status-deploy              : Query the status of a software deployment, requires --update and --servers\n \
  restart                    : Restart a service on all servers of a server group \n \
  rollback                   : Rollback a software deployment\n \
  status-rollback            : Query the status of a software deployment rollback\n \
  list-server-groups         : Display a list of all defined server groups. If an update file is listed \n \
                               in addition, it shows whether an update has been applied for that group. \n \
  list-server-group-members  : Show all servers represented by a server group \n \
  check-missing              : Display a list of all servers which don't have an update installed \n \
  pkgdb-source               : Re-read the package status of a given host into the package database")


opt, args = op.parse_args()

if len (args) == 0 or len (args) > 1:
    op.print_help()
    sys.exit(1)

command = args[0]

if command in ("deploy", "status-deploy", "rollback", "status-rollback", "restart", "list-server-group-members"):
    if not opt.serverlist:
        op.error("You need to provide a server list (-s)")
    if opt.serverlist not in conf.server_groups.keys():
        op.error("Invalid server group. It needs to be defined in /etc/debdeploy.conf")

if command in ("deploy", "status-deploy", "rollback", "status-rollback"):
    if not opt.updatefile:
        op.error("You need to provide an update file (-u)")

if command in ("restart"):
    if not opt.program:
        op.error("You need to provide a program to restart (-p)")

if command in ("pkgdb-source"):
    if not opt.host:
        op.error("You need to provide a hostname (-h)")

if command == "deploy":
    update = DebDeployUpdateSpec(opt.updatefile, conf.supported_distros)
    deploy_update(update.source, update.update_type, conf.server_groups[opt.serverlist], opt.updatefile, opt.serverlist)

elif command == "restart":
    restart(conf.server_groups[opt.serverlist], opt.program)

elif command == "status-deploy":
    display_status()

elif command == "status-rollback":
    display_status(rollback_mode=True)

elif command == "rollback":
    rollback(opt.serverlist, opt.updatefile)

elif command == "list-server-group-members":
    list_server_group_members(opt.serverlist)

elif command == "list-server-groups":
    if opt.updatefile:
        list_server_groups(opt.updatefile)
    else:
        list_server_groups()

sys.exit(0)

# Local variables:
# mode: python
# End:
